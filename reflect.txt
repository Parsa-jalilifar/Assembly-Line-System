// Name: Parsa Jalilifar
// Seneca Student ID:133308189
// Seneca email: pjalilifar@myseneca.ca
// Date of completion:
//
// I confirm that the content of this file is created by me,
//   with the exception of the parts provided to me by my professor.

Problems and learnings
Doing the milestones was a good challenge for me to determine the knowledge that I gathered 
during this semester.  In milestone one, everything was easy because we had practice how to 
extract tokens in our previous workshops but a hard time was when I was trying to write my 
code for extracToken function. Start point and the string will be given to the function then 
it finds delimiter pos number and subtract fist pos and delimiter pos from each other to 
extract token and finally set fist pos to after delimiter pos number.

	size_t delimiter_pos = str.find(m_delimiter, next_pos + 1);
	size_t wordLength = (delimiter_pos - next_pos) ;
	std::string token = str.substr(next_pos, wordLength);
	next_pos = delimiter_pos + 1;

double-pointer was a new thing for me when I was doing milstone2, the first time I wrote 
destructor I did it wrong and after study for the last quiz, I learned how to do it. 
I like the way I used count algorithm to determine m_cntItem and I think that I showed my 
creativity for use algorithm for counting the number of tokens.

m_cntItem = std::count(strCustomerOrder.begin(), strCustomerOrder.end(), temp.getDelimiter()) - 1;

for (size_t i = 0; i < m_cntItem; i++)
	{
		delete m_lstItem[i];
	}
	delete[] m_lstItem;

the hardest millstone among three milestones, it was milestone3 because the way guidance was 
guiding was not too clear what should I need to do. However, after u present inside of our 
lab, I got a better idea. I loved using two for-loop for check items inside of my constructor
then we set to task.

if (record.find(util.getDelimiter()) != std::string::npos)
		{
			std::string token = util.extractToken(record, pos, ok);
			std::string taskToken = util.extractToken(record, pos, ok);

			for (size_t i = 0; i < AssemblyLine.size(); i++)
			{
				if (AssemblyLine[i]->getName() == token)
				{
					for (size_t j = 0; j < AssemblyLine.size(); j++)
					{
						if (AssemblyLine[j]->getName() == taskToken)
						{
							AssemblyLine[i]->setNextTask(*AssemblyLine[j]);
						}
					}
				}
			}
		}
